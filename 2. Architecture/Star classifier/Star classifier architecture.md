# Декомпозиция задач
### Задачи:
1. Обработать входные данные:
    - Обработать (декодировать) параметры запуска.
    - Обработать изображение:
        - Загрузить его из файла.
        - Декодировать его.
1. Выделить все звёзды на изображении:
    - Способ 1:
        - Применить цветовой фильтр (Какой? Скорее всего, серый), преобразовать контрастность (Это лучше сделать до или после цветового фильтра?).
        - Применить медианный фильтр (если надо).
        - Применить фильтр Гаусса.
        - Применить фильтр Собеля.
        - Если надо, построить компоненты связности (система непересекающихся множеств).
        - Распознать, в каких местах изображения остались яркие маленькие кружочки.
    - Способ 2:
        - Применить цветовой фильтр (Какой? Скорее всего, серый. А может быть, вообще никакой), преобразовать контрастность (это лучше сделать до или после цветового фильтра? Или вообще не делать, если мы не применяем цветовой фильтр?).
        - Применить фильтр Гаусса.
        - Выделить компоненты связности (это можно делать и на цветной картинке).
        - Распознать, какие компоненты связности отвечают за звёзды.
1. Получить информацию о звёздах (из обработанного изображения или компонент связности).
1. Получить результирующее изображение, используя информацию о звёздах (или наоборот).
1. Сохранить обработанное изображение в файл:
    - Закодировать изображение.
    - Сохранить закодированное изображение в файл.
1. Сохранить информацию о звёздах в файл:
    - Закодировать её в строку нужного формата.
    - Сохранить строку в файл.
1. Вернуть результат вызывающей стороне:
    - Так как результат составной, удобнее будет сделать доступ к разным частям результата через отдельные поля/методы класса.
    - Можно для каждой части результата создать свой класс, имеющий необходимые функции преобразования к другому типу.


Используем подход MVC (Model-View-Controller).

### Пространства имен:
1. Model
1. View
1. Controller
1. UI (user interface)
1. OS (operation system)
1. Errors
1. Filters
1. DataStructures
1. Config

#### Пример использования:

View: эй, контроллер, пользователь хочет сохранить результат в файл!

Контроллер: эй, Model, выдай мне результат в виде std::string, разбитого на строки в нужном формате! //// Эй, Model, выдай мне результат в виде int** array, а я его конвертирую в строку.
Предпочтительнее второй вариант???

Контроллер: эй, OS, вот тебе строка, запихай ее в файлик пж!



!!!\ !!!ДОЛЖНО БЫТЬ ЛЕГКО РЕАЛИЗУЕМО БЕЗ ИЗМЕНЕНИЙ СУЩЕСТВУЮЩЕГО КОДА!!!:
ДОБАВИТЬ НОВЫЙ ВИД ОБВОДКИ!
ДОБАВИТЬ НОВОЕ ПРЕДСТАВЛЕНИЕ (ФОРМАТ ВЫВОДА) - СКАЖЕМ, WEB ДОКУМЕНТ, TCP ПОТОК, etc.

TODO (и сверху, и снизу)

От 2 до 7 модулей на каждом иерархическом уровне

### Интерфейсы:
1. В пространстве имён Model:
    - Pixel
        - Поля:
            - red
            - green
            - blue
            - alpha
    - Image
        - Поля:
            - size_t size
        - Функции:
            - outline_star(size_t x, size_t y)
            - operator[size_t][size_t]
            - begin (const and non-const)
            - end (const and non-const)
            - new_instance() или clone() - (надо подумать, нужен ли нам чистый холст - тогда оптимизируем время на копирование и функция выглядит просто как return new ConcreteClass(), или нужны ли нам копии - тогда придется копировать) - чтобы возвращали указатель на нужный класс (то есть тот, который мы изначально передавали в StarClassifier)
    - ImageDoubleIterator (по идее он нужен, для двойной индексации нужно сделать так, надо спросить gpt на примере линейного прохода по int[][])
        - Функции:
            - ImageIterator& operator*
    - ImageIterator
        - Функции:
            - T& operator*
            - ImageIterator& operator++
            - bool operator!=
    - Star
        - Поля:
            - x
            - y
            - radius
    - Stars
        - Поля:
            - size
        - Функции:
            - operator[unsigned int]
            - begin (const and non-const)
            - end (const and non-const)
    - StarsIterator
        - Функции:
            - T& operator*
            - StarsIterator& operator++
            - bool operator!=
    - StarClassifier
1. В пространстве имён View:
    - View
1. В пространстве имён Controller:
    - Controller
1. В пространстве имён UI:
    - Input
    - Output
1. В пространстве имён OS:
    - FileSystem
    - Console ??? TODO
    - CommandLine ??? TODO
1. В пространстве имён Config:
    - Config


TODO скорее всего, в одном и том же пространстве имён будут разные классы под разные задачи, каждый класс в своём файле
Общий .h, много .cpp, один интерфейс, много реализаций

### Классы
1. В пространстве имён Model:
    - StarClassifier
1. В пространстве имён View:
    - ConsoleApplication
    - StaticLibraryApplication
    - GraphicApplication
    - CommandLineApplication
1. В пространстве имён Controller:
    - Controller (основной)
1. В пространстве имён UI:
    - pass
1. В пространстве имён OS:
    - WindowsFileSystem
    - Console ??? TODO
    - CommandLine ??? TODO
1. В пространстве имён Errors:
    - BaseError
        - FileError
            - FileLoadError
            - FileReadError
            - FileSaveError
1. В пространстве имён DataStructures:
    - DisjointUnionSet (по идее, ему не нужны интерфейсы, DUS всегда одинаковый же, а если понадобится, наследуемся от него в нужном месте/исправим его и код прямо в том куске, где он будет использоваться - по идее, это одно место)

### Структуры данных
1. Pixel
1. Image - это может быть классом
1. Star
1. Stars - это может быть классом
1. Params - то, что нужно для star classifier (список входных параметров в требованиях). Может быть, есть название получше. В соответствии с требованиями, можно зашарашить туда конструктор с половиной параметров по умолчанию.

### Структуры данных
1. В пространстве имён DataStructures:
    - DisjointUnionSet

### Функции
1. В пространстве имён Filters:
    - MedianFilter
    - GaussianFilter
    - SobelFilter

```cpp
int main(argc, argv) {
    UI ui = ConcreteUI();
    Params params = ui.get_input_params(arcg, argv);
    StarClassifier starClassifier = StarClassifier(params);
    // после этой строки имеем:
    auto image = starClassifier.image;
    auto stars = starClassifier.stars;
    // И че с этим делать дальше?
    // Вариант 1:
    Actions actions = ui.get_actions();
    for (auto action : actions) {
        action.execute(image, stars);
    }
    // Вроде как это плохая реализация. Тогда, может быть...
    // Вариант второй:
    ui.update(image, stars);
    // А если в ui добавится еще какие-то штуки? В update 100500 параметров не засунешь...
    // И, самое главное - здесь НЕТ контроллера, вместо него выступает main!
}
```
