# Декомпозиция задач
### Задачи:
1. Обработать входные данные:
    - Обработать (декодировать) параметры запуска.
    - Обработать изображение:
        - Загрузить его из файла.
        - Декодировать его.
1. Выделить все звёзды на изображении:
    - Способ 1:
        - Применить цветовой фильтр (Какой? Скорее всего, серый), преобразовать контрастность (Это лучше сделать до или после цветового фильтра?).
        - Применить медианный фильтр (если надо).
        - Применить фильтр Гаусса.
        - Применить фильтр Собеля.
        - Если надо, построить компоненты связности (система непересекающихся множеств).
        - Распознать, в каких местах изображения остались яркие маленькие кружочки.
    - Способ 2:
        - Применить цветовой фильтр (Какой? Скорее всего, серый. А может быть, вообще никакой), преобразовать контрастность (это лучше сделать до или после цветового фильтра? Или вообще не делать, если мы не применяем цветовой фильтр?).
        - Применить фильтр Гаусса.
        - Выделить компоненты связности (это можно делать и на цветной картинке).
        - Распознать, какие компоненты связности отвечают за звёзды.
1. Получить информацию о звёздах (из обработанного изображения или компонент связности).
1. Получить результирующее изображение, используя информацию о звёздах (или наоборот).
1. Сохранить обработанное изображение в файл:
    - Закодировать изображение.
    - Сохранить закодированное изображение в файл.
1. Сохранить информацию о звёздах в файл:
    - Закодировать её в строку нужного формата.
    - Сохранить строку в файл.
1. Вернуть результат вызывающей стороне:
    - Так как результат составной, удобнее будет сделать доступ к разным частям результата через отдельные поля/методы класса.
    - Можно для каждой части результата создать свой класс, имеющий необходимые функции преобразования к другому типу.


Используем подход MVC (Model-View-Controller).

### Пространства имен:
1. Model
1. View
1. Controller
1. UI (user interface)
1. OS (operation system)
1. Errors
1. Filters
1. DataStructures
1. Config

#### Пример использования:

### Интерфейсы:
1. В пространстве имён Model:
    - Pixel
        - Поля:
            - red
            - green
            - blue
            - alpha
    - Image
        - Поля:
            - size_t size
        - Функции:
            - outline_star(size_t x, size_t y)
            - operator[size_t][size_t]
            - begin (const and non-const)
            - end (const and non-const)
            - new_instance() или clone() - (надо подумать, нужен ли нам чистый холст - тогда оптимизируем время на копирование и функция выглядит просто как return new ConcreteClass(), или нужны ли нам копии - тогда придется копировать) - чтобы возвращали указатель на нужный класс (то есть тот, который мы изначально передавали в StarFinder)
    - ImageIterator
        - Функции:
            - T& operator*
            - ImageIterator& operator++
            - bool operator!=
            - get_x
            - get_y
    - Star
        - Поля:
            - x
            - y
            - radius
    - Stars
        - Поля:
            - size
        - Функции:
            - operator[unsigned int]
            - begin (const and non-const)
            - end (const and non-const)
    - StarsIterator
        - Функции:
            - T& operator*
            - StarsIterator& operator++
            - bool operator!=
            - get_index
    - StarFinder
        - Функции:
            - find_stars
            - get_image
            - get_stars
1. В пространстве имён View:
    - View
1. В пространстве имён Controller:
    - Controller
1. В пространстве имён UI:
    - Input
    - Output
1. В пространстве имён OS:
    - FileSystem
    - Console ??? TODO
    - CommandLine ??? TODO
1. В пространстве имён Config:
    - Config


TODO скорее всего, в одном и том же пространстве имён будут разные классы под разные задачи, каждый класс в своём файле
Общий .h, много .cpp, один интерфейс, много реализаций

#### Было принято решение реализовать публичные функции get_x(), get_y(), get_index() у итераторов, так как они, скорее всего, всё равно будут хранить соответствующие поля для итерации, и эти функции - просто инлайны. А с точки зрения оптимизации гораздо выгоднее написать один цикл через итератор, и поля брать у итератора, чем цикл с переменными i,j. С таким интерфейсом можно, при необходимости, реализовать отдельно итераторы по строке/столбцу/любого другого доступа и не запутаться, на что указывает итератор.

TODO
StarFinder - имеено интерфейс? Вдруг мы захотим StarFinder, который выделяет самую яркую звезду/сортирует по яркости/выделяет созвездия? У него другой набор функций и полей (у нашего пока из полей только image и stars, он их задает при вызове find_stars() - чтобы при вызове конструктора не запускать поиск звёзд - вдруг он нам не понадобится - ленивая логика.) К тому же, конструктор принимает в себя только один параметр Params (было бы удобно, а Params - тоже интерфейс, там должны быть как минимум image, а как максимум - все, чего душе угодно: ограничение на яркость выделяемых звёзд, как их обводить (тоже кстати хороший вопрос, как это передавать - может сразу как функцию, но это вроде как пока кринж.))

То есть проблемка в InputParams и (если так можно выразиться) OutputParams. Если сделать максимально абстрактный интерфейс, то контроллеру придется вызывать cast для преобразования абстрактного StarFinder (у которого считай один конструктор в интерфейсе, и возможно функии get_image()) в конкретный, который выдаст набор звёзд / отсортированных по яркости (если будем создавать наследника интерфейса, который их отсортирует); в самом StarFinder придется вызывать cast, чтобы прочитать необходимые ему поля (а это еще и в конструкторе, а если нам подсунули некорректные данные - то throw из конструктора делать) и т.д.

Чтобы не throw из конструктора, можно сделать функцию init(). В конструкторе все поля в nullptr, в init - задавать им значения или throw error.
Хотя, концепция кинуть ошибку из конструктора вроде лучше.

https://stackoverflow.com/questions/810839/throwing-exceptions-from-constructors

Когда кидаем ошибку из конструктора, деструктор не вызывается (очевидно):

https://stackoverflow.com/questions/810839/throwing-exceptions-from-constructors#:~:text=the%20destructors%20are%20not%20called%2C%20so%20if%20a%20exception%20need%20to%20be%20thrown%20in%20a%20constructor%2C%20a%20lot%20of%20stuff(e.g.%20clean%20up%3F)%20to%20do.

### Классы
1. В пространстве имён Model:
    - StarFinder
1. В пространстве имён View:
    - ConsoleApplication
    - StaticLibraryApplication
    - GraphicApplication
    - CommandLineApplication
1. В пространстве имён Controller:
    - Controller (основной)
1. В пространстве имён UI:
    - pass
1. В пространстве имён OS:
    - WindowsFileSystem
    - Console ??? TODO
    - CommandLine ??? TODO
1. В пространстве имён Errors:
    - BaseError
        - FileError
            - FileLoadError
            - FileReadError
            - FileSaveError
1. В пространстве имён DataStructures:
    - DisjointUnionSet (по идее, ему не нужны интерфейсы, DUS всегда одинаковый же, а если понадобится, наследуемся от него в нужном месте/исправим его и код прямо в том куске, где он будет использоваться - по идее, это одно место)

### Структуры данных
1. Pixel
1. Image - это может быть классом
1. Star
1. Stars - это может быть классом
1. Params - то, что нужно для StarFinder (список входных параметров в требованиях). Может быть, есть название получше. В соответствии с требованиями, можно зашарашить туда конструктор с половиной параметров по умолчанию.

TODO up down (оставить одно из двух)

### Структуры данных
1. В пространстве имён Model:
    - StarFinderParams
1. В пространстве имён DataStructures:
    - DisjointUnionSet

### Функции
1. В пространстве имён Filters:
    - MedianFilter
    - GaussianFilter
    - SobelFilter

```cpp
int main(argc, argv) {
    UI ui = ConcreteUI();
    Params params = ui.get_input_params(arcg, argv);
    StarFinder starFinder = StarFinder(params);
    // после этой строки имеем:
    auto image = starFinder.image;
    auto stars = starFinder.stars;
    // И че с этим делать дальше?
    // Вариант 1:
    Actions actions = ui.get_actions();
    for (auto action : actions) {
        action.execute(image, stars);
    }
    // Вроде как это плохая реализация. Тогда, может быть...
    // Вариант второй:
    ui.update(image, stars);
    // А если в ui добавится еще какие-то штуки? В update 100500 параметров не засунешь...
    // И, самое главное - здесь НЕТ контроллера, вместо него выступает main!
}
```
